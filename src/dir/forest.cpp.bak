#include "../include/forest.hpp"
#include <cstdlib> // For std::rand and std::srand
#include <ctime>   // For std::time
#include <iostream> // For debug traces
#include <sstream>  // For std::stringstream
#include <OgreOverlaySystem.h>
#include <SDL2/SDL_keycode.h> // Pour les constantes des touches SDL
#include <Ogre.h> // Pour corriger l'avertissement de dépréciation

// CustomContactResultCallback a été déplacé dans PhysicsManager.hpp

Forest::Forest()
    : ApplicationContext("Zforest"), 
      scnMgr(nullptr),
      root(nullptr),
      object(nullptr),
      planeZ(nullptr),
      player(nullptr),
      zombies(nullptr),
      overlaySystem(nullptr),
      shadergen(nullptr),
      lastFrameTime(0.0f),
      lodDistanceThreshold(500.0f),
      gameStarted(false),
      cameraManager(nullptr),
      levelManager(nullptr),
      inputManager(nullptr),
      physicsManager(nullptr),
      uiManager(nullptr)
{
}

Forest::~Forest()
{
    // Clean up test cube bodies
    if (physicsManager) {
        btDiscreteDynamicsWorld* dynamicsWorld = physicsManager->getDynamicsWorld();
        if (dynamicsWorld) {
            for (btRigidBody* body : testCubeBodies) {
                if (body) {
                    if (body->getMotionState()) {
                        delete body->getMotionState();
                    }
                    if (body->getCollisionShape()) {
                        delete body->getCollisionShape();
                    }
                    dynamicsWorld->removeRigidBody(body);
                    delete body;
                }
            }
            testCubeBodies.clear();
        }
    }

    // Clean up manager classes
    delete uiManager;
    delete physicsManager;
    delete inputManager;
    delete levelManager;
    delete cameraManager;

    // Clean up game objects
    delete zombies;
    delete player;
    delete planeZ;
    delete object;
    delete overlaySystem;
}

void Forest::setup()
{
    // Masquer la page d'accueil
    if (uiManager) {
        uiManager->hideWelcomePage();
    }
    
    gameStarted = true;
    
    // Initialiser les éléments du jeu
    btDiscreteDynamicsWorld* dynamicsWorld = physicsManager ? physicsManager->getDynamicsWorld() : nullptr;
    
    // Créer le plan (terrain)
    planeZ = new PlaneZ();
    if (planeZ && dynamicsWorld) {
        planeZ->createPlane(scnMgr, dynamicsWorld);
    }
    
    // Créer les objets (arbres, etc.)
    object = new Object();
    if (object && dynamicsWorld) {
        object->createObject(scnMgr, dynamicsWorld);
    }
    
    // Créer le joueur
    player = new Player();
    if (player && dynamicsWorld) {
        player->createPlayer(scnMgr, Ogre::Vector3::ZERO, dynamicsWorld);
    }
}

void Forest::quitGame()
{
    getRoot()->queueEndRendering();
}

bool Forest::keyPressed(const OgreBites::KeyboardEvent& evt)
{
    if (!gameStarted) {
        return true;
    }

    if (inputManager) {
        inputManager->keyPressed(evt);
    }

    if (evt.keysym.sym == OgreBites::SDLK_ESCAPE) {
        getRoot()->queueEndRendering();
    }

    return true;
}

bool Forest::keyReleased(const OgreBites::KeyboardEvent& evt)
{
    if (!gameStarted) {
        return true;
    }

    if (inputManager) {
        inputManager->keyReleased(evt);
    }

    return true;
}

bool Forest::mouseMoved(const OgreBites::MouseMotionEvent& evt)
{
    if (!gameStarted) {
        return true;
    }

    if (inputManager && player) {
        inputManager->mouseMoved(evt);
    }

    return true;
}

bool Forest::mousePressed(const OgreBites::MouseButtonEvent& evt)
{
    if (!gameStarted) {
        return true;
    }

    if (inputManager && player && physicsManager) {
        inputManager->mousePressed(evt, player, physicsManager->getDynamicsWorld());
    }

    return true;
}

bool Forest::mouseReleased(const OgreBites::MouseButtonEvent& evt)
{
    if (!gameStarted) {
        if (uiManager && uiManager->getTrayManager()) {
            return uiManager->getTrayManager()->mouseReleased(evt);
        }
        return true;
    }

    if (inputManager) {
        inputManager->mouseReleased(evt);
    }

    return true;
}

void Forest::createLight()
{
    light = scnMgr->createLight("MainLight");
    if (light) {
        light->setDiffuseColour(Ogre::ColourValue(0.8f, 0.6f, 0.4f));
        light->setSpecularColour(Ogre::ColourValue(0.5f, 0.4f, 0.3f));
        light->setPowerScale(2.0f);

        lightNode = scnMgr->getRootSceneNode()->createChildSceneNode();
        lightNode->attachObject(light);
        lightNode->setPosition(Ogre::Vector3(500, 600, 500));
        lightNode->setDirection(Ogre::Vector3(-1, -1, -1).normalisedCopy());
    }
}

bool Forest::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
    if (!gameStarted) {
        if (uiManager && uiManager->getTrayManager()) {
            uiManager->getTrayManager()->frameRendered(evt);
        }
        return true;
    }

    // Update physics
    if (physicsManager) {
        physicsManager->stepSimulation(evt.timeSinceLastFrame);
    }

    // Update camera
    if (cameraManager && player && player->playerNode) {
        cameraManager->updateCameraPosition(player->playerNode->getPosition());
    }

    return true;
}

void Forest::setup()
{
    ApplicationContext::setup();
    addInputListener(this);

    // Initialize random seed
    std::srand(static_cast<unsigned>(std::time(nullptr)));

    root = getRoot();
    scnMgr = root->createSceneManager();
    
    if (!scnMgr) {
        throw std::runtime_error("Failed to create SceneManager");
    }

    overlaySystem = getOverlaySystem();
    scnMgr->addRenderQueueListener(overlaySystem);

    // Set fog
    Ogre::ColourValue fogColor(0.1f, 0.1f, 0.1f);
    scnMgr->setFog(Ogre::FOG_LINEAR, fogColor, 0.001f, 500, 2000);

    // Initialize shader generator
    shadergen = RTShader::ShaderGenerator::getSingletonPtr();
    if (shadergen) {
        RTShader::ShaderGenerator::initialize();
        shadergen->addSceneManager(scnMgr);
    }

    // Create resource group for shaders
    Ogre::ResourceGroupManager::getSingleton().createResourceGroup(
        RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME);

    // Initialize manager classes
    // 1. Physics Manager
    physicsManager = new PhysicsManager();
    physicsManager->initialize();
    physicsManager->setupDebugDrawer(scnMgr);
    
    // 2. Camera Manager
    cameraManager = new CameraManager(scnMgr, getRenderWindow());
    
    // 3. UI Manager
    uiManager = new UIManager(scnMgr, getRenderWindow());
    uiManager->initialize();
    
    // 4. Level Manager
    levelManager = new LevelManager(scnMgr, physicsManager->getDynamicsWorld());
    
    // 5. Input Manager
    inputManager = new InputManager(physicsManager->getDynamicsWorld());
    
    // Set up UI callbacks
    uiManager->setPlayCallback([this]() {
        this->startGame();
    });
    
    uiManager->setQuitCallback([this]() {
        this->quitGame();
    });
    
    // Add TrayManager as input listener
    if (uiManager->getTrayManager()) {
        addInputListener(uiManager->getTrayManager());
    }
}

    // Set fog
    ColourValue fogColor(0.1f, 0.1f, 0.1f);
    scnMgr->setFog(FOG_LINEAR, fogColor, 0.001f, 500, 2000);

    // Initialize shader generator
    shadergen = RTShader::ShaderGenerator::getSingletonPtr();
    if (shadergen) {
        RTShader::ShaderGenerator::initialize();
        shadergen->addSceneManager(scnMgr);
    }

    // Create resource group for shaders
    ResourceGroupManager::getSingleton().createResourceGroup(
        RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME);

    // Initialize manager classes
    // 1. Physics Manager
    physicsManager = new PhysicsManager();
    physicsManager->initialize();
    physicsManager->setupDebugDrawer(scnMgr);
    
    // 2. Camera Manager
    cameraManager = new CameraManager(scnMgr, getRenderWindow());
    // Pas besoin d'appeler initialize() car createCamera() est appelé dans le constructeur
    
    // 3. UI Manager
    uiManager = new UIManager(scnMgr, getRenderWindow());
    uiManager->initialize();
    
    // 4. Level Manager
    levelManager = new LevelManager(scnMgr, physicsManager->getDynamicsWorld());
    
    // 5. Input Manager
    inputManager = new InputManager(physicsManager->getDynamicsWorld());
    
    // Set up UI callbacks
    uiManager->setPlayCallback([this]() {
        this->startGame();
    });
    
    uiManager->setQuitCallback([this]() {
        this->quitGame();
    });
    
    // Add TrayManager as input listener
    if (uiManager->getTrayManager()) {
        addInputListener(uiManager->getTrayManager());
    }
}

// La méthode initializeWelcomePage a été déplacée vers UIManager

void Forest::startGame()
{
    // Masquer la page d'accueil
    if (uiManager) {
        uiManager->hideWelcomePage();
    }
    
    // Marquer le jeu comme démarré
    gameStarted = true;
    
    // Initialiser les éléments du jeu
    
    // Créer le plan (terrain)
    planeZ = new PlaneZ();
    if (planeZ) {
        planeZ->createPlane(scnMgr, dynamicsWorld);
    }
    
    // Créer les objets (arbres, etc.)
    object = new Object();
    if (object) {
        object->createObject(scnMgr, dynamicsWorld);
    }
    
    // Créer le joueur
    player = new Player();
    if (player) {
        player->createPlayer(scnMgr, Vector3::ZERO, dynamicsWorld);
    }
    
    // Créer les zombies
    zombies = new Zombies();
    if (zombies) {
        zombies->createZombies(scnMgr, zombiesPerLevel, 500.0f, dynamicsWorld);
    }
    
    // Créer la minimap
    minimap = new Minimap();
    if (minimap) {
        minimap->initialize(scnMgr);
    }
    
    // Créer le HUD
    hud = new HUD();
    if (hud) {
        hud->initialize();
    }
    
    // Créer le crosshair
    crosshair = new Crosshair();
    if (crosshair) {
        crosshair->initialize(scnMgr);
    }
    
    // Réinitialiser le jeu pour le niveau 1
    resetGame();
}

void Forest::quitGame()
{
    // Fermer l'application
    getRoot()->queueEndRendering();
}

// La méthode moveCamera a été déplacée vers InputManager

bool Forest::keyPressed(const OgreBites::KeyboardEvent& evt)
{
    if (!gameStarted) {
        // Si le jeu n'est pas démarré, ne pas traiter les entrées clavier
        return true;
    }

    // Déléguer la gestion des touches à InputManager
    if (inputManager) {
        inputManager->keyPressed(evt);
    }

    // Gérer les touches spéciales au niveau de l'application
    if (evt.keysym.sym == OgreBites::SDLK_ESCAPE) {
        getRoot()->queueEndRendering();
    } else if (evt.keysym.sym == OgreBites::SDLK_r) {
        if (levelManager) {
            levelManager->resetGame();
        }
    } else if (evt.keysym.sym == OgreBites::SDLK_n) {
        if (levelManager) {
            levelManager->startNextLevel();
        }
    }

    return true;
}

bool Forest::keyReleased(const OgreBites::KeyboardEvent& evt)
{
    if (!gameStarted) {
        return true;
    }

    // Déléguer la gestion des touches à InputManager
    if (inputManager) {
        inputManager->keyReleased(evt);
    }

    return true;
}

// La méthode updateMovementAndAnimation a été déplacée vers InputManager

bool Forest::mouseMoved(const OgreBites::MouseMotionEvent& evt)
{
    if (!gameStarted) {
        return true;
    }

    // Déléguer la gestion du mouvement de la souris à InputManager
    if (inputManager && player) {
        inputManager->mouseMoved(evt);
    }

    return true;
}

bool Forest::mousePressed(const OgreBites::MouseButtonEvent& evt)
{
    if (!gameStarted) {
        return true;
    }

    // Déléguer la gestion des clics de souris à InputManager
    if (inputManager && player && physicsManager) {
        inputManager->mousePressed(evt, player, physicsManager->getDynamicsWorld());
    }

    return true;
}

bool Forest::mouseReleased(const OgreBites::MouseButtonEvent& evt)
{
    if (!gameStarted) {
        if (welcomePage && welcomePage->getTrayManager()) {
            return welcomePage->getTrayManager()->mouseReleased(evt);
        }
        return true;
    }

    // Déléguer la gestion des relâchements de souris à InputManager
    if (inputManager) {
        inputManager->mouseReleased(evt);
    }

    return true;
}

void Forest::createLight()
{
{{ ... }}
    light = scnMgr->createLight("MainLight");
    if (light) {
        light->setDiffuseColour(ColourValue(0.8f, 0.6f, 0.4f));
        light->setSpecularColour(ColourValue(0.5f, 0.4f, 0.3f));
        light->setPowerScale(2.0f);

        lightNode = scnMgr->getRootSceneNode()->createChildSceneNode();
        lightNode->attachObject(light);
        lightNode->setPosition(Vector3(500, 600, 500));
        lightNode->setDirection(Vector3(-1, -1, -1).normalisedCopy());
    }
}

// La méthode createCam a été déplacée vers CameraManager

Vector3 targetCameraPosition;
// La méthode checkLevelCompletion a été déplacée vers LevelManager

// La méthode displayLevelInfo a été déplacée vers UIManager

// La méthode resetGame a été déplacée vers LevelManager

bool Forest::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
    // Si le jeu n'est pas démarré, ne mettre à jour que la page d'accueil
    if (!gameStarted) {
        if (uiManager && uiManager->getTrayManager()) {
            uiManager->getTrayManager()->frameRendered(evt);
        }
        return true;
    }

    // Update lastFrameTime
    lastFrameTime = evt.timeSinceLastFrame;

    // Vérifier si le joueur est vivant
    if (!player || !player->isAlive()) {
        if (levelManager) {
            levelManager->resetGame();
        }
        return true;
    }

    // Mise à jour de la physique
    if (physicsManager) {
        physicsManager->stepSimulation(evt.timeSinceLastFrame);
    }

    // Mise à jour des LODs
    if (object && cameraManager && scnMgr) {
        object->updateObjectLODs(cameraManager->getCameraNode(), scnMgr);
    }

    // Mise à jour de la position du joueur
    if (player && player->playerBody) {
        btVector3 position = player->playerBody->getWorldTransform().getOrigin();
        player->playerNode->setPosition(position.x(), 0, position.z());

        // Mise à jour des animations et de la santé du joueur
        player->updateAnimations(evt.timeSinceLastFrame);
        player->updateHealth(evt.timeSinceLastFrame);
    }

    // Mise à jour de la caméra
    if (cameraManager && player) {
        cameraManager->updateCameraPosition(player->playerNode->getPosition());
    }

    // Mise à jour du niveau
    if (levelManager) {
        levelManager->update(evt.timeSinceLastFrame);
        levelManager->checkLevelCompletion();
    }

    // Mise à jour des zombies et gestion des collisions
    if (levelManager && player) {
        levelManager->updateZombies(evt.timeSinceLastFrame);
        levelManager->checkZombiePlayerCollisions(player);
    }

    // Gestion des collisions entre balles et zombies
    if (physicsManager && levelManager && player) {
        physicsManager->checkBulletZombieCollisions(player, levelManager->getZombies());
        player->updateBulletPositions(physicsManager->getDynamicsWorld());
    }

    // Mise à jour de l'interface utilisateur
    if (uiManager && player) {
        // Mise à jour de la minimap
        if (player->playerNode) {
            uiManager->updateMinimap(
                player->playerNode->getPosition(),
                levelManager ? levelManager->getZombiePositions() : std::vector<Vector3>(),
                object ? object->getTreePositions() : std::vector<Vector3>()
            );
        }
        
        // Mise à jour du HUD
        uiManager->updateHUD(player->getHealth(), player->getEnergy());
        
        // Mise à jour du crosshair
        uiManager->updateCrosshair();
    }

    return true;
}

// Ces méthodes ont été déplacées dans les classes manager appropriées